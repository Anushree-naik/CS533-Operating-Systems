<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/~kstew2/style.css" type="text/css" media="screen" title="no title" charset="utf-8">
<title>Assignment 2: Round-Robin Scheduling</title>
</head>
<body>
<div id=content>
<h1>Assignment 2: Round-Robin Scheduling</h1>

<p><strong>Due Date: Friday, October 23rd</strong></p>

<h2>Overview</h2>

<p>In the <a href="../assign1">last assignment</a>, we developed a mechanism for 
context-switching between two running threads. In order for our system to be 
useful, however, we'd like to extend it to deal with an arbitrary number of 
threads that can be dynamically created (and destroyed) during program 
execution.</p>

<h2>Design Choices</h2>

<h3>Scheduling and State</h3>

<p>If we are to have an arbitrary number of threads in our system, we need to make
two crucial choices: first, how should we manage and store the thread control
blocks associated with these threads? Second, when a thread gives up control of
the CPU by finishing its task or by calling <code>yield()</code>, how should we decide
which thread to run next?</p>

<p>Fortunately, there is a convenient data structure that can manage our thread
control blocks, and implement a simple round-robin (aka FIFO) scheduling policy:
a queue. When the thread finishes or yields, the scheduler will put that thread
at the end of a queue of waiting threads, and pull the next thread off the front
of the queue to run.</p>

<p>Recall that in the last assignment, we ran into trouble if a thread returned
return from its initial function, and then tried to return from <code>thread_wrap</code>.
The program crashed because the <code>ret</code> instruction at the end of <code>thread_wrap</code>
would cause the CPU to try and pop an address off the empty thread stack and 
jump to it -- but since the stack was empty, that address was most likely
nonsense, leading to a segmentation fault. </p>

<p>One potential solution to this problem is to stick a
call to <code>yield</code> at the end of <code>thread_wrap</code>; however, this is not enough to
prevent a crash, since another thread could call <code>yield</code> again, switching
back to the point just before <code>thread_wrap</code> tries to return. We could instead
put that <code>yield</code> in an infinite loop; this would cause any attempt to switch
back to a finished thread to immediately switch to something else. However, this
solution incurs significant penalties: the memory of the finished thread is
never freed, and worse, a long-running system will be dominated by finished
threads yielding to each other.</p>

<p>What can we do to effectively communicate the "doneness" of a thread, such that
the scheduler can free its resources and never switch back to it? We can
extend our thread control block to include a <code>state</code> field, which the scheduler
can use to make decisions about what to do with a thread.</p>

<h3>The Scheduler Interface</h3>

<p>Starting with this assignment, we'd also like to start pushing the scheduler's
implementation away from application code, only connecting the two through a
well-defined API (application programming interface). In the last assignment,
scheduler code (such as the setup and initialization of <code>current_thread</code>) were
mixed in with application code (such as printing out the results of
computations). This would certainly be confusing for a user, but it is probably
even more confusing for you as a library designer!</p>

<p>In this assignment, we'll implement the following simple scheduler API:</p>

<p><table></p>

<p><tr> 
    <td> <code>scheduler_begin</code> </td> 
    <td> to take care of one-time setup and initialization </td> 
  </tr></p>

<p><tr> 
    <td> <code>thread_fork</code> </td>
    <td> to allocate, initialize, and run a new thread </td>
  </tr></p>

<p><tr>
    <td> <code>yield</code> </td> 
    <td> to switch among runnable threads </td>
  </tr></p>

<p><tr> 
    <td> <code>scheduler_end</code> </td> 
    <td> to wait for all threads in the system to finish. </td>
  </tr></p>

<p></table></p>

<h2>Implementation</h2>

<h3>Preparation</h3>

<ol>
<li><p>Make a new directory for your second assignment. Copy your assembly
 code files from assignment 1 into the new directory.
 To save you time and let you focus on the important aspects of this
 assignment, I've written a simple queue ADT for you to use, which
 has an enqueue and dequeue function, and an <code>is_empty</code> predicate. 
 Additionally, the dequeue function returns
 <code>NULL</code> if the queue is empty.
 Add the files
 <a href="queue.h">queue.h</a> and <a href="queue.c">queue.c</a> to your folder. It may 
 be convenient to do this with the <code>wget</code> command in bash, e.g.:</p>

<pre><code>   $ wget http://cs.pdx.edu/~kstew2/cs533/project/assign2/queue.h 
   $ wget http://cs.pdx.edu/~kstew2/cs533/project/assign2/queue.c
</code></pre>

<p>Note: this queue implementation assumes your thread control block
 C <code>struct</code> is called <code>struct thread</code>. It should still work fine if you've
 created a <code>typedef</code>, as long as <code>struct thread</code> is still defined somewhere.</p></li>
<li><p>Start a new file called <code>scheduler.h</code>, and copy in your definition
 for <code>struct thread</code> from the first assignment. Add prototypes for
 the API functions outlined above:</p>

<pre><code>  void scheduler_begin();
  void thread_fork(void(*target)(void*), void * arg);
  void yield();
  void scheduler_end();
</code></pre>

<p>Also, add the following declaration:</p>

<pre><code>  extern struct thread * current_thread;
</code></pre>

<p>This will allow any file that <code>#include</code>s <code>scheduler.h</code> to have
 access to the <code>current_thread</code> global variable, even though it
 will be defined in <code>scheduler.c</code>.</p></li>
<li><p>Start a new file called <code>scheduler.c</code> and copy your definitions
 of <code>yield</code> and <code>thread_wrap</code> from the first assignment. Notice
 that I have not instructed you to include a prototype for <code>thread_wrap</code> 
 in <code>scheduler.h</code> Why might this be?</p></li>
<li><p>Here is a sample application: <a href="main.c">main.c</a>. Take a look at it for
 an idea of how your scheduler API should be used. You may use this program
 to test your scheduler implementation, but I encourage you to create
 your own tests as well!</p></li>
<li><p>When everything is set up, your compilation line should look something like
 this:</p>

<pre><code>  gcc main.c scheduler.c queue.c switch.s
</code></pre>

<p>With whatever additional options and flags you are accustomed to using.
 Of course, this will not compile at this stage, since we have not
 implemented any of the API functions.</p></li>
</ol>

<h3>Interface</h3>

<ol>
<li><p>Add the following <code>enum</code> definition to <code>scheduler.h</code>:</p>

<pre><code>  typedef enum {
    RUNNING, // The thread is currently running.
    READY,   // The thread is not running, but is runnable.
    BLOCKED, // The thread is not running, and not runnable.
    DONE     // The thread has finished. 
  } state_t;
</code></pre>

<p>Extend your thread control block data structure with a new field,
 <code>state_t state</code>. It should go at the end of the <code>struct</code> definition
 to avoid interfering with our assembly code's assumptions about
 the layout of the structure.</p></li>
<li><p>In <code>scheduler.c</code>, define two global variables, <code>struct thread *
 current_thread</code> and <code>struct queue ready_list</code>.</p></li>
<li><p>Implement <code>scheduler_begin</code>. It should do the following:</p>

<ol>
<li>Allocate the <code>current_thread</code> thread control block and set its
state to <code>RUNNING</code>. The other fields need not be initialized;
at the moment, this is an empty shell that will hold the main thread's
stack pointer when it first gets switched out.</li>
<li>Set the <code>head</code> and <code>tail</code> fields of <code>ready_list</code> to <code>NULL</code> to
indicate that the ready list is empty.</li>
</ol></li>
<li><p>Next, let's implement <code>thread_fork</code>. This function encapsulates
 everything necessary to allocate a new thread and then jump to it.
 <code>thread_fork</code> should:</p>

<ol>
<li>Allocate a new thread control block, and allocate its stack.</li>
<li>Set the new thread's initial argument and initial function.</li>
<li>Set the current thread's state to <code>READY</code> and
enqueue it on the ready list.</li>
<li>Set the new thread's state to <code>RUNNING</code>.</li>
<li>Save a pointer to the current thread in a temporary variable,
then set the current thread to the new thread.</li>
<li>Call <code>thread_start</code> with the old current thread as <code>old</code> and
the new current thread as <code>new</code>.</li>
</ol></li>
<li><p><code>yield</code> is very similar to <code>thread_fork</code>, with the main difference
 being that it is pulling the next thread to run off of the ready
 list instead of creating it. <code>yield</code> should: </p>

<ol>
<li>If the current thread is not <code>DONE</code>, set its state
  to <code>READY</code> and enqueue it on the ready list. </li>
<li>Dequeue the next thread from the ready list and set its
  state to <code>RUNNING</code>.  </li>
<li>Save a pointer to the current thread in a temporary variable,
  then set the current thread to the next thread.</li>
<li>Call <code>thread_switch</code> with the old current thread as <code>old</code>
  and the new current thread as <code>new</code>.</li>
</ol></li>
<li><p>Finally, recall from the first assignment that we need
 a way to prevent the main thread from terminating prematurely
 if there are other threads still running. Implement a solution
 to this problem in <code>scheduler_end</code>. (Hint: you may find
 the <code>is_empty</code> queue function useful).</p></li>
</ol>

<p>A snapshot of a running scheduler with a few threads might look something like
this:</p>

<p><img src="scheduler.png" alt="Scheduler" title="" /> </p>

<h3>Testing</h3>

<p>You may use the <a href="main.c">provided test program</a>, or write your own. What
makes this program a good test? What more could you add?</p>

<h2>Discussion</h2>

<p>Think about the answers to the following questions, and discuss them with
your peers if you'd like.</p>

<ol>
<li><p>Memory management is not included in the instructions above. Given this
setup, what is an intuitive way to solve the problem of memory reclamation for
thread stacks and thread control blocks? What could we
do to avoid excessive allocations and deallocations?</p></li>
<li><p>When executing scheduler code (e.g. <code>yield</code>, <code>thread_fork</code>, etc), are we
running in a thread? Which thread? At what precise point can we say we have
stopped running one thread's code and started running another? This is a
deliberately open-ended question; just give your thoughts.</p></li>
<li><p>What other functionality would you find useful in a threading API?
Can you think of a multi-threaded application that you cannot write
given this simple interface?</p></li>
</ol>

<h2>What To Hand In</h2>

<p>You should submit:</p>

<ol>
<li><p>All library and application code. This should include:</p>

<ul>
<li><code>switch.s</code></li>
<li><code>queue.h</code></li>
<li><code>queue.c</code></li>
<li><code>scheduler.h</code></li>
<li><code>scheduler.c</code></li>
<li><code>main.c</code></li>
</ul></li>
<li><p>A brief written report, including:</p>

<ol>
<li><p>A description of what you did and how you chose to test it.</p></li>
<li><p>Your responses to the discussion questions posed above. If feel like you 
got a good idea from a peer, make sure to cite them for it and try
to give your own thoughts on their idea as well.</p></li>
</ol></li>
</ol>

<p>Please submit your code files <em>as-is</em>; do not copy them into a Word document or PDF.<br>
Plain text is also preferred for your write-up.</p>

<p>Email your submission to the TA at <u>kstew2 at cs.pdx.edu</u> on or before the due date.
The subject line should be "CS533 Assignment 2".</p>

<h2>Need Help?</h2>

<p>If you have any questions or concerns, or want clarification, feel free
to <a href="/kstew2/cs533/">contact the TA</a> by coming to office hours or sending an email.</p>

<p>You may also send an email to the 
<a href="https://mailhost.cecs.pdx.edu/mailman/listinfo/cs533">class mailing list</a>. Your
peers will see these emails, as will the TA and professor.</p>

</div>
</body>
</html>
