<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css" media="screen" title="no title" charset="utf-8">
<title>Assignment 1: Context Switching</title>
</head>
<body>
<div id=content>
<h1>Assignment 1: Context Switching</h1>

<p><strong>Due Date: Friday, October 7th</strong></p>

<h2>Overview</h2>

<p>Throughout this project, we will be developing various parts of a user-level
interface for programming with threads, similar to that described in Birrell's
<a href="http://web.cecs.pdx.edu/~walpole/
class/cs533/papers/thread_intro.pdf">An Introduction to Programming with Threads</a>, with some important differences
that will become clear as the project progresses.</p>

<p>The first part of each assignment will be a bit of overview, followed by a
discussion of the design choices one is faced with when designing and
implementing a particular part of the threading interface. In this assignment,
we will begin to implement the data structures that store information about the
threads themselves, as well as some basic mechanisms for switching control flow
between two different threads.</p>

<h2>Design Choices</h2>

<h3>Data Structures</h3>

<p>Since all threads in a particular program share an address space, we must
decide where in that address space each part of the thread will live.
Concretely, we need a data structure representing the thread's vital
information (commonly called a "thread control block"), which the threading
library will use to maintain and manage the state of each thread. We also
need space for the thread's activation stack, which will be used by the
compiler and hardware to manage local variables, function calls, and so forth.</p>

<p>In this project, the activation for each thread after the main thread (where
the <code>main()</code> function starts) will live in the heap, while the main thread's stack
will live in the stack area of the address space, as it usually does:</p>

<pre><code>Address space:
|======================| High Addresses
| Main Thread Stack  | |
|                    v |
|======================|
| Heap:                |
|----------------------|
| Thread 1 Stack     | |
|                    v |
|----------------------|
| Thread 2 Stack     | |
|                    v |
|----------------------|
| etc ...              |
|======================|
| Data                 |
|======================|
| Text                 |
|======================| Low Addresses
</code></pre>

<p>Something to think about: can you see any potential problems with this design?
What happens if the main thread runs out of stack space? What about the
subordinate threads? What could you do to prevent a stack overflow in either case?</p>

<p>Allowing the thread stacks to live in the heap allows the number of
threads in the system to be flexible and unknown at compilation time. This
implies that the thread control blocks must also live in the heap, so they can
be dynamically created and destroyed.</p>

<h3>Context Switching</h3>

<p>Context switching refers to the control-flow jump that occurs when one
thread gives up the CPU and another thread takes over. Like a function call,
it involves pushing values on the system stack and manipulating CPU registers.
Unlike a function call, which has explicit entry and exit points,
a context switch can happen at any time, without warning. If a stack
and set of registers represents everything you need to know about a control flow
(its context), then the entire context must be saved before switching to another
one.</p>

<p>There is no explicit way to do this at the C language level. Therefore, context
switching must be directly implemented at the assembly language level.
The core assembly mechanism we will use to switch between thread stacks is to 
change the value of the system stack pointer register (<code>%rsp</code> on the
x86-64 machines we will be using).</p>

<h2>Implementation</h2>

<h3>Step 1: Data Structures</h3>

<p>Write a C data structure, <code>struct thread</code>, to represent a thread control
block. For now, it should have at least these fields: </p>

<ul>
<li><p>A stack pointer: <code>unsigned char* stack_pointer</code></p>

<ul>
<li>Note: an <code>unsigned char</code> is a single byte, thus a variable of type 
<code>unsigned char*</code> is a pointer to an array of single bytes. 
However, I find it clearer to use a type without another meaning. 
If you want to be as clear as possible, you can add a type synonym with 
<code>typedef unsigned char byte</code>, and then make the type <code>byte*</code>.</li>
</ul></li>
<li><p>A pointer to an initial function: <code>void (*initial_function)(void*)</code></p>

<ul>
<li>Note: this creates a variable named <code>initial_function</code> that is a pointer 
to functions that take a single <code>void*</code> parameter and return no
values.
For more on function pointer syntax, <a href="
http://www.cprogramming.com/tutorial/function-pointers.html">see here</a>.</li>
</ul></li>
<li><p>A pointer to an initial argument: <code>void* initial_argument</code></p>

<ul>
<li><code>void*</code> variables (aka void pointers) are used to allow pointers to
values of <em>any</em> type to be passed in to a function. 
We use them here because
it gives us the most general interface for defining initial
functions for threads.
For more on void pointers, <a href="http://theory.uwinnipeg.ca/
programming/node87.html">see here</a>.</li>
</ul></li>
</ul>

<p>Write a short function that takes an argument of type <code>void*</code> and
returns nothing. It can do whatever you like! Here is an example that
shows off how the <code>void*</code> parameter might get used:</p>

<pre><code>  int factorial(int n) {
    return n == 0 ? 1 : n * factorial(n-1);
  }

  void fun_with_threads(void * arg) {                                              
    int n = *(int*) arg;
    printf("%d! = %d\n", n, factorial(n));                                   
  }
</code></pre>

<p>Create a global pointer to a <code>struct thread</code> called <code>current_thread</code>, 
and write a short <code>main</code> program to allocate space for <code>current_thread</code>
and for the thread's stack, then initialize each field of <code>current_thread</code>.
Initializing the initial function is easy: just give the name of the
function, e.g.:</p>

<pre><code>  current_thread-&gt;initial_function = fun_with_threads;
</code></pre>

<p>The initial argument is a little more complicated, since you should
allocate some data on the heap and then use a pointer to it, like so:</p>

<pre><code>  int * p = malloc(sizeof(int));
  *p = 5;
  current_thread-&gt;initial_argument = p;
</code></pre>

<p>Notice that you don't have to explicitly cast <code>p</code> (which is type <code>int*</code>)
to type <code>void*</code>. This is called "upcasting": going from a more specific
type to a less specific type. However, in <code>fun_with_threads</code> above,
<code>arg</code> must be explicitly cast <em>back</em> to type <code>int*</code>. We know that in this case,
<code>arg</code> is really a pointer to an integer, but the compiler doesn't. 
This is called "downcasting": going from a less specific type
to a more specific type.</p>

<p>When you initialize the thread's stack pointer, recall that it needs
to point to the <em>end</em> of the allocated region, since stacks grow towards
lower addresses. For example:</p>

<pre><code>  current_thread-&gt;stack_pointer = malloc(STACK_SIZE) + STACK_SIZE;
</code></pre>

<p>What should the value of <code>STACK_SIZE</code> be? This is a tough question that
depends on the application. Thankfully, modern machines have memory to burn,
so let's make our stacks be 1 megabyte (1024 * 1024 bytes).</p>

<p>So far, we've crafted a really ugly way to call a function:</p>

<pre><code>  current_thread-&gt;initial_function(current_thread-&gt;inital_argument);
</code></pre>

<p>We don't quite have threading yet. For that, we'll need to implement
some more machinery.</p>

<h3>Step 2: Context Switching</h3>

<p>The basic way to switch between two established contexts is relatively
straightforward: save all of the registers on the current stack, switch stacks,
and restore all the registers off the new stack. We'll call this operation
<code>thread_switch</code>, with the following prototype (in your C file):</p>

<pre><code>  void thread_switch(struct thread * old, struct thread * new);
</code></pre>

<p>And the following implementation (in a separate assembly file; <a href="
asm_hints.md">see here</a> for some assembly writing tips):</p>

<ol>
<li>Push all callee-save registers (<code>%rbx, %rbp, %r12-15</code>) onto the current stack.</li>
<li>Save the current stack pointer (<code>%rsp</code>) in <code>old</code>'s thread control block.</li>
<li>Load the stack pointer from <code>new</code>'s thread control block into <code>%rsp</code>.</li>
<li>Pop all callee-save registers from the new stack.</li>
<li>Return.</li>
</ol>

<p>Note that this method switches between two established threads. What if
we want to switch to a new thread? Presumably, this thread would have
an empty stack, so step 4 would make no sense. Additionally, we need
a way to start executing the initial function of the new thread.
Let's call this other operation <code>thread_start</code>. It has a very similar
prototype and implementation to <code>thread_switch</code>:</p>

<pre><code>  void thread_start(struct thread * old, struct thread * new);
</code></pre>

<ol>
<li>Push all callee-save registers onto the current stack.</li>
<li>Save the current stack pointer in <code>old</code>'s thread control block.</li>
<li>Load the stack pointer from <code>new</code>'s thread control block into <code>%rsp</code>.</li>
<li>Call the initial function of <code>new</code>.</li>
</ol>

<p>Step 4 above is a little open ended, as there are a few ways to do it.
We could load the new thread's initial argument into the first argument
register (<code>%rdi</code>) and jump to the initial function. Or, we could
jump to a C function that calls the initial function using C syntax.
This is more desirable, for reasons that will become clear later. Let's
call this C wrapper function <code>thread_wrap</code>. Right now, it only needs
one line:</p>

<pre><code>  void thread_wrap() {
    current_thread-&gt;initial_function(current_thread-&gt;inital_argument);
  }
</code></pre>

<p>We're almost ready to start up a new thread. You should have a <code>main</code> function that
creates and sets up a <code>current_thread</code> TCB (thread control block). Keep in mind
that at the time this data structure is allocated, it's not referring to
the real current thread. This can be a little mind-bending, but it will become
the current thread soon. Meanwhile, we will need a place to park the context of
the (currently running) main thread, which will become inactive.</p>

<p>Create another global pointer to a <code>struct thread</code>
called <code>inactive_thread</code>. Allocate space for this thread control block.
You don't have to allocate space for its stack, or initialize
its initial function or initial argument. Why not?</p>

<p>Okay, now that both the (soon to be) <code>current_thread</code> and the (soon to be)
<code>inactive_thread</code> are set up, you're ready to call <code>thread_start</code> in <code>main</code>:</p>

<pre><code>  thread_start(inactive_thread, current_thread);
</code></pre>

<p>You should see the output of your initial function... and then the program
should crash with a <code>Segmentation fault</code>. This is the expected behavior at this
stage! But why? We'll get to this in a moment, but first let's develop a way
to use <code>thread_switch</code> to go back to the main thread before our subordinate
thread finishes.</p>

<h3>Step 3: Yielding</h3>

<p>Before we can call <code>thread_switch</code>, we'll need to swap the <code>current_thread</code>
and <code>inactive_thread</code> pointers, so we maintain the condition that
outside of setup and switching code, <code>current_thread</code> always refers to the
thread control block of the thread that's currently running. We'll use
the following function, a primitive form of <code>yield</code>:</p>

<pre><code>  void yield() {
    struct thread * temp = current_thread;
    current_thread = inactive_thread;
    inactive_thread = temp;
    thread_switch(inactive_thread, current_thread);
  }
</code></pre>

<p>Experiment with calling <code>yield</code> to switch back and forth between the subordinate
thread and the main thread. You might try putting a loop in each that allows
you to go back and forth a fixed number of times. Notice that if the loop
in the subordinate thread finishes first, the program crashes with
a segmentation fault, as before. What happens if the loop in the main
thread finishes first? Why?</p>

<h3>Step 4: Thread Termination</h3>

<p>Back to our segmentation fault issue.  What's going on? Well, when the initial
function ends, it returns back to <code>thread_wrap</code>, which ends and then tries to
return back to the function that called it. <strong>But nothing called
<code>thread_wrap</code></strong>. It was the first function executed on an empty stack, and you
can't unwind an empty stack any further. What our thread needs is an exit point:
a way to clean up the thread's state and switch back to some other task.</p>

<p>One thing we can do is to put a call to <code>yield</code> at the end of <code>thread_wrap</code>:</p>

<pre><code>  void thread_wrap() {
    current_thread-&gt;initial_function(current_thread-&gt;inital_argument);
    yield();
  }
</code></pre>

<p>Now, when the thread's initial function finishes, no matter what it was,
it will return to <code>thread_wrap</code>, which will call <code>yield</code>. The inactive
main thread will be switched in, and execution will continue at the point
of the last <code>thread_switch</code> or <code>thread_start</code> called by the main thread.</p>

<p>One other thing we might be tempted to do in <code>thread_wrap</code> is free memory
associated with the thread, e.g. its activation stack and thread
control block. Be careful, however! We cannot free memory associated
with the thread while it is still running. Think about what we could do
to delay the deallocation until it is safe.</p>

<h2>Discussion</h2>

<p>Think about the answers to the following questions, and discuss them with
your peers if you'd like.</p>

<ol>
<li><p>What would be an elegant way to create and manage an arbitrary number
of threads?</p></li>
<li><p>Can you think of any uses for even the very simple form of threading
we've developed in this assignment? What extra features could we add
to make it more useful?</p></li>
<li><p>Memory management can be a challenge in threading systems. When is it
safe to free a thread's stack? What about its thread control block?
How would this change if we wanted to return results from our threads, 
or implement a <code>join</code> procedure? 
(see the <a href="http://web.cecs.pdx.edu/~walpole/
class/cs533/papers/thread_intro.pdf">Birrell article</a> for a description of <code>join</code>)</p></li>
</ol>

<h2>What To Hand In</h2>

<p>You should submit:</p>

<ol>
<li><p>All code you'd like to submit for this assignment.</p></li>
<li><p>A brief written report, including:</p>

<ol>
<li><p>A description of what you did and how you chose to test it.</p></li>
<li><p>Your responses to the discussion questions posed above. If feel like you 
got a good idea from a peer, make sure to cite them for it and try
to give your own thoughts on their idea as well.</p></li>
</ol></li>
</ol>

<p>Please submit your code files <em>as-is</em>; do not copy them into a Word document or PDF.<br>
Plain text is also preferred for your write-up.</p>

<p>Email your submission to <a href="../../">the TA</a> on or before the due date.
The subject line should be "CS533 Assignment 1".</p>

<h2>Need Help?</h2>

<p>If you have any questions or concerns, or want clarification, feel free
to <a href="../../">contact the TA</a> by coming to office hours or sending an email.</p>

<p>You may also send an email to the 
<a href="https://mailhost.cecs.pdx.edu/mailman/listinfo/cs533">class mailing list</a>. Your
peers will see these emails, as will the TA and professor.</p>

</div>
</body>
</html>
